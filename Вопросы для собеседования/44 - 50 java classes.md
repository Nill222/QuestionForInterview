# Внутренние классы в Java

Внутренние классы помогают логически группировать код, инкапсулировать детали реализации и работать с окружением внешнего класса. Их четыре вида: member (нестатический), static nested, local, anonymous.

## Виды внутренних классов и цели использования

- **Нестатический внутренний класс (member inner class):** Живет внутри внешнего класса, привязан к экземпляру внешнего.
    
    - **Цели:** Инкапсуляция деталей, тесно связанных с состоянием внешнего объекта; доступ к приватным полям внешнего класса.
        
    - **Особенности:** Имеет неявную ссылку `Outer.this`; не может иметь статических членов (кроме констант).
        
    - **Пример:**
        
    
    java
    
    ```
    class Outer {
        private int state = 42;
        class Inner {
            int doubleOuter() { return state * 2; } // доступ к private
        }
    }
    ```
    
- **Статический вложенный класс (static nested class):** Статический член внешнего класса.
    
    - **Цели:** Логическая группировка, когда связь с внешним классом концептуальная, но не нужна ссылка на экземпляр.
        
    - **Особенности:** Не имеет ссылки на `Outer.this`; может иметь статические члены.
        
    - **Пример:**
        
    
    java
    
    ```
    class Outer {
        static class Nested {
            static int util(int x) { return x * x; }
        }
    }
    ```
    
- **Локальный класс (local class):** Объявляется внутри блока (метод, конструктор, инициализатор).
    
    - **Цели:** Вспомогательная логика рядом с использованием, скрытая от остального кода.
        
    - **Особенности:** Доступ к переменным метода, если они «эффективно final»; не виден вне блока.
        
    - **Пример:**
        
    
    java
    
    ```
    void process() {
        int base = 10; // эффективно final
        class Worker {
            int run(int x) { return base + x; }
        }
        System.out.println(new Worker().run(5));
    }
    ```
    
- **Анонимный класс (anonymous class):** Без имени; однократное расширение класса или реализация интерфейса.
    
    - **Цели:** Быстрое определение поведения «на месте», особенно для коллбеков и стратегий.
        
    - **Особенности:** Один класс/интерфейс в заголовке; нет конструктора с именем; нельзя иметь статические объявления (кроме констант).
        
    - **Пример:**
        
    
    java
    
    ```
    Runnable r = new Runnable() {
        @Override public void run() { System.out.println("Hi"); }
    };
    ```
    

## Области видимости и доступ к данным

- **Доступ из inner к outer:**
    
    - **Правило:** Внутренние классы (включая локальные и анонимные) имеют доступ ко всем членам внешнего класса, включая `private`.
        
    - **Явное указание внешнего:** `Outer.this.field` и `Outer.this.method()` — когда есть теневание имен.
        
- **Доступ outer к inner:**
    
    - **Правило:** Требуется экземпляр внутреннего:
        
    
    java
    
    ```
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    ```
    
- **Локальный/анонимный к переменным метода:**
    
    - **Правило:** Можно читать только «эффективно final» переменные (значение не изменяется после присвоения). Это связано с копированием значения в скрытое поле при компиляции.
        
- **Статический вложенный класс:**
    
    - **Правило:** Не имеет доступа к нестатическим членам внешнего класса без явного экземпляра.
        
- **Теневание (shadowing):**
    
    - **Правило:** Если имя поля совпадает, приоритет у ближайшей области. Для доступа к внешнему используйте `Outer.this.field`.
        

# Анонимные классы: применение и ограничения

- **Практическое применение:**
    
    - **Коллбеки/слушатели событий:** До появления лямбд — `ActionListener`, `Runnable`, `Callable`.
        
    - **Стратегии и адаптеры:** Разовые реализации `Comparator`, `InputStream`, «обертки» для тестов.
        
    - **Контекстно-зависимое поведение:** Временная модификация поведения при передаче в методы.
        
- **Когда нельзя создать анонимный класс:**
    
    - **От final-класса:** Нельзя наследовать от `final` (например, `String`, `Integer`).
        
    - **От enum, record или annotation:** Нельзя анонимно расширять `enum`, `record`, `@interface`.
        
    - **Для примитивов и массивов:** Только классы/интерфейсы подходят.
        
    - **С несколькими родителями:** Анонимный класс может расширять только один класс или реализовать один интерфейс в объявлении; для нескольких интерфейсов используйте именованный класс.
        
    - **Когда нужен именованный конструктор:** У анонимного класса нет имени конструктора; можно лишь использовать «инициализатор» блока.
        
- **Совет:** В современном Java предпочтительнее лямбды, если вы реализуете функциональные интерфейсы (один абстрактный метод). Анонимные классы — для случаев, где нужно состояние, дополнительные методы или реализация не функционального интерфейса.
    

# Generics: назначение, стирание типов и wildcards

- **Что это и для чего:**
    
    - **Типобезопасность:** Переносят ошибки типов на компиляцию (например, `List<String>`).
        
    - **Самодокументация:** Делают API явным по типам.
        
    - **Устранение cast-ов:** Нет необходимости в приведениях при чтении.
        
- **Во что превращается при компиляции и выполнении (type erasure):**
    
    - **Компиляция:** Проверяются типовые ограничения, добавляются приведения и мостовые методы.
        
    - **Стирание:** Параметры типов стираются до верхней границы (обычно `Object` или указанного bound), поэтому в рантайме `List<String>` и `List<Integer>` — один класс `java.util.ArrayList`.
        
    - **Следствия:**
        
        - Нельзя `new T()`, нельзя `T.class`, нельзя создавать массивы параметризованных типов: `new List<String>[10]` — нельзя.
            
        - Перегрузка по параметрам типов не работает, отражение не видит различий параметризаций.
            
        - Проверка `instanceof List<String>` невозможна; только `instanceof List`.
            
- **Wildcards (**`?`**):**
    
    - `? extends T`**:** «Читатель». Можно читать как `T`, добавлять нельзя (кроме `null`).
        
        - Пример: источники данных `List<? extends Number>`.
            
    - `? super T`**:** «Писатель». Можно класть `T` и его подтипы, читать безопасно только как `Object`.
        
        - Пример: цели для записи `List<? super Integer>`.
            
    - **Правило PECS:** Producer Extends, Consumer Super.
        
- **Bounded type parameters:**
    
    - **Ограничения:** `<T extends Number & Comparable<T>>` — верхние границы классов и интерфейсов.
        
    - **Пример:**
        
    
    java
    
    ```
    static <T extends Comparable<T>> T max(List<T> list) {
        T best = list.get(0);
        for (T t : list) if (t.compareTo(best) > 0) best = t;
        return best;
    }
    ```
    
- **Частые ошибки:**
    
    - **Инвариантность:** `List<Integer>` не является `List<Number>`. Используйте `List<? extends Number>`.
        
    - **Массивы ковариантны, generics — нет:** Arrays допускают runtime-ошибки, generics — compile-time проверку.
        
    - **Raw types:** Избегайте `List` без параметров — теряете типобезопасность.
        

# Enum: назначение, применение и ошибки использования

- **Что такое enum:**
    
    - **Перечисление конечного набора констант:** Каждая константа — экземпляр класса `Enum`-типа; можно добавлять поля, методы, конструкторы (всегда `private`).
        
    - **Пример:**
        
    
    java
    
    ```
    enum Status {
        NEW, IN_PROGRESS, DONE;
    }
    ```
    
- **Применение:**
    
    - **Доменные состояния:** Статусы заказов, роли, типы операций.
        
    - **Поведение по константе:** Переключение `switch`, стратегия через переопределение методов константами.
        
    - **Инструменты:** `EnumSet`, `EnumMap` — эффективные структуры для enum-ключей.
        
- **Расширенные возможности:**
    
    java
    
    ```
    enum Operation {
        PLUS { double apply(double a, double b) { return a + b; } },
        MINUS{ double apply(double a, double b) { return a - b; } };
        abstract double apply(double a, double b);
    }
    ```
    
- **Некорректное использование:**
    
    - **Динамические данные:** Enum не для сущностей, список которых меняется в рантайме (например, значения из БД).
        
    - **Слишком много mutable-состояния:** Мутируемые поля в enum приводят к shared mutable state (один экземпляр на константу) — опасно для потоков.
        
    - **Перегрузка бизнес-логики:** Огромные `switch` по enum вместо полиморфизма или стратегий.
        
    - **Сериализация внешних значений:** Привязка к `ordinal()` хрупка; используйте стабильные `name()` или явные коды.
        
    - **Антипаттерн «enum как конфиг»:** Хранить пользовательские настройки/внешние ресурсы в enum — делает их негибкими.
        

# Отличия Comparator и Comparable

|Атрибут|Comparable|Comparator|
|---|---|---|
|Где определяется|Внутри класса объекта|В отдельном классе/лямбде|
|Интерфейс|`int compareTo(T o)`|`int compare(T a, T b)`|
|Кол-во порядков|Один «естественный» порядок|Сколько угодно различных порядков|
|Использование|`Collections.sort(list)` если T implements Comparable|Передается явным параметром: `sort(list, comparator)`|
|Гибкость|Низкая: жестко зашит в тип|Высокая: легко менять критерии|

> Sources: интерфейсы стандартной библиотеки Java

- **Рекомендации:**
    
    - **Comparable:** Когда есть естественный порядок (например, `LocalDate`, `BigDecimal`).
        
    - **Comparator:** Когда порядок зависит от контекста (по цене, по имени, по нескольким полям) или нельзя/не хотите менять тип.
        
- **Примеры:**
    
    java
    
    ```
    class Person implements Comparable<Person> {
        String name; int age;
        @Override public int compareTo(Person o) {
            return name.compareTo(o.name); // естественный порядок: по имени
        }
    }
    
    Comparator<Person> byAgeDesc = Comparator.comparingInt(p -> p.age).reversed();
    ```
    

# Optional: борьба с null, хорошие и плохие практики

- **Зачем нужен Optional:**
    
    - **Явно выражает «может не быть» в возвращаемом значении.**
        
    - **Устраняет** `NullPointerException`**-паттерны:** Предлагает композицию операций (`map`, `flatMap`, `filter`, `orElseGet`) вместо `if (x != null)`.
        
- **Хорошее использование:**
    
    - **Возврат из репозиториев/поиска:**
        
    
    java
    
    ```
    Optional<User> findById(String id) { ... }
    
    String email = findById("42")
        .map(User::getProfile)
        .map(Profile::getEmail)
        .filter(e -> e.contains("@"))
        .orElse("unknown@example.com");
    ```
    
    - **Преобразования без NPE:** Чистая композиция без явных null-проверок.
        
- **Некорректное использование:**
    
    - **В полях сущностей и параметрах методов:** `Optional` предназначен для возвращаемых значений; поля/параметры усложняют модель и расходуют память.
        
    - **Коллекции** `Optional`**:** `List<Optional<T>>` почти всегда признак плохого дизайна — используйте просто `List<T>` и фильтрацию.
        
    - `get()` **без проверки:** Бросит `NoSuchElementException`; используйте `orElse`, `orElseGet`, `orElseThrow`.
        
    - `orElse` **с тяжелыми вычислениями:** Аргумент вычисляется всегда. Предпочитайте `orElseGet(() -> heavy())`.
        
    - **Сериализация/DTO:** Опционал — логика, а не данные; в DTO лучше явные nullable-поля или отдельные типы.
        

# Принципы SOLID, YAGNI, KISS, DRY

- **S (Single Responsibility):**
    
    - **Идея:** Один класс — одна причина для изменения.
        
    - **Практика:** Разделяйте логику: валидаторы, конвертеры, сервисы, репозитории — отдельно.
        
- **O (Open/Closed):**
    
    - **Идея:** Расширяемость без модификации существующего кода.
        
    - **Практика:** Интерфейсы, стратегии, шаблоны (Factory, Strategy), enum c поведением.
        
- **L (Liskov Substitution):**
    
    - **Идея:** Подтип должен быть взаимозаменяем с базовым без сюрпризов.
        
    - **Практика:** Не ослабляйте постусловия, не усиливайте предусловия; избегайте неожиданных исключений.
        
- **I (Interface Segregation):**
    
    - **Идея:** Мелкие целевые интерфейсы лучше, чем «толстые».
        
    - **Практика:** Не заставляйте имплементаторов реализовывать ненужные методы.
        
- **D (Dependency Inversion):**
    
    - **Идея:** Зависимости — от абстракций, а не от реализаций.
        
    - **Практика:** Внедрение зависимостей, фабрики, события; модули общаются через интерфейсы.
        
- **YAGNI (You Aren’t Gonna Need It):**
    
    - **Идея:** Не реализуй, пока не нужен.
        
    - **Практика:** Минимизируйте «на будущее», пишите по требованиям.
        
- **KISS (Keep It Simple, Stupid):**
    
    - **Идея:** Простые решения более надежны.
        
    - **Практика:** Избегайте ненужной абстракции; понятный код важнее трюков.
        
- **DRY (Don’t Repeat Yourself):**
    
    - **Идея:** Одна истина в одном месте.
        
    - **Практика:** Общие утилиты, переиспользуемые компоненты; не дублируйте бизнес-правила.
        

# Вызов метода не из интерфейса/абстрактного базового типа

- **Сценарий:**
    
    java
    
    ```
    interface Interf { /* no method() */ }
    class Clazz implements Interf {
        void method() { System.out.println("X"); }
    }
    Interf a = new Clazz();
    a.method(); // ?
    ```
    
- **Ответ:** Некорректно. Компиляция ошибется: метод `method()` не объявлен в `Interf`.
    
    - **Как правильно:** Либо объявите метод в интерфейсе (включая `default`), либо приведите тип:
        
    
    java
    
    ```
    ((Clazz) a).method(); // безопасно только если точно Clazz
    ```
    
- **То же с абстрактным классом:** Правило идентично. Вызываемые методы должны быть объявлены в статическом типе ссылки.
    

# ClassLoader, статика и синглтоны

- **Что такое ClassLoader:**
    
    - **Механизм загрузки классов в JVM:** Отвечает за поиск байткода, преобразование в `Class`, изоляцию модулей/приложений.
        
    - **Модель делегации:** Обычно родительская делегация (bootstrap → platform → application). Можно делать кастомные лоадеры для плагинов.
        
- **Статические переменные между разными ClassLoader-ами:**
    
    - **Правило:** Класс, загруженный разными лоадерами, считается разными типами. Статика хранится отдельно в каждом загрузчике.
        
    - **Следствие:** Изменение `static` в одном ClassLoader не видно экземпляру того же класса, загруженному другим.
        
- **Синглтоны и ClassLoader:**
    
    - **Правило:** «Один» — на ClassLoader. Если один и тот же класс загружен несколькими лоадерами, будет несколько независимых синглтонов.
        
    - **Практика:** В серверах приложений, OSGi, плагинных системах — учитывайте границы ClassLoader-ов. Для глобальной уникальности используйте внешнее хранилище (процесс- или системного уровня), либо сервис-локатор/DI-контейнер на уровне корневого лоадера.
        
- **Мини-демо:**
    
    java
    
    ```
    // Псевдо: два лоадера загружают один и тот же класс синглтона
    Class<?> c1 = loaderA.loadClass("com.example.Singleton");
    Class<?> c2 = loaderB.loadClass("com.example.Singleton");
    Object s1 = c1.getMethod("getInstance").invoke(null);
    Object s2 = c2.getMethod("getInstance").invoke(null);
    System.out.println(s1 == s2); // false: разные классы/лоадеры
```