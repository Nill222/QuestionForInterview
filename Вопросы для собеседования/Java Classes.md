## Важно Базовый класс Object и его методы

#### Зачем нужен Object

- **Идея:** В Java все классы в итоге происходят от одного общего предка — `java.lang.Object`. Это даёт единый набор базовых возможностей для каждого объекта.
    
- **Почему так:** Это упрощает работу коллекций, сравнения объектов, превращение их в строки, синхронизацию потоков и т.д.
    

#### Ключевые методы и простыми словами, зачем они

- **equals(Object o):** логическое равенство объектов по содержимому. По умолчанию сравнивает ссылки (т.е. одинаковые ли объекты в памяти).
    
- **hashCode():** числовая “подпись” объекта для быстрых структур данных (например, `HashMap`). Связан с `equals`.
    
- **toString():** “человеческое” строковое представление объекта. Полезно для логов и отладки.
    
- **getClass():** возвращает класс объекта во время выполнения (рефлексия).
    
- **clone():** создать копию объекта (поверхностно, если не переопределено).
    
- **finalize():** вызывался сборщиком мусора перед удалением объекта; устарел и не рекомендуется.
    
- **wait()/notify()/notifyAll():** средства синхронизации потоков на уровне объекта (при работе с `synchronized`).
    
- **Пример:** Когда ты кладёшь объект в `HashSet`, он использует `hashCode` для корзины, а затем `equals`, чтобы понять, равен ли объект уже существующему.
    

## Важно Абстракция и четыре принципа ООП

#### Абстракция

- **Смысл:** Скрыть реализацию и оставить только важный интерфейс взаимодействия. Например, коллекция позволяет добавлять элементы, но скрывает детали хранения.
    
- **Инструменты:** интерфейсы, абстрактные классы, сокрытие полей.
    

#### Четыре столпа ООП

- **Инкапсуляция:** скрываем поля (private), открываем безопасные методы (get/set). Защищает от неправильного использования.
    
- **Наследование:** берём общий базовый класс и расширяем/уточняем. Экономит код, но может усложнить зависимость.
    
- **Полиморфизм:** один интерфейс — разные реализации. Позволяет писать код “против” абстракций.
    
- **Абстракция:** выделяем существенное, убираем детали. Снижает сложность.
    

> Пример: У тебя есть интерфейс `List`. Он абстрактен; конкретные реализации `ArrayList` и `LinkedList` разные внутри, но снаружи — один контракт.

## Правила equals(Object o) и почему они важны

#### Контракт equals — 5 свойств

- **Рефлексивность:** объект равен сам себе.
    
- **Симметричность:** если A равен B, то B равен A.
    
- **Транзитивность:** если A равен B и B равен C, то A равен C.
    
- **Консистентность:** результат не меняется, если объект не менялся.
    
- **С null:** любой объект не равен `null`.
    

#### Практическая реализация

- **Шаги:**
    
    - Сравнить ссылки: `if (this == o) return true;`
        
    - Проверить `null`: `if (o == null) return false;`
        
    - Проверить тип: `if (getClass() != o.getClass()) return false;` или `instanceof` если допускаешь наследников.
        
    - Сравнить значимые поля: для объектов — через их `equals`, для примитивов — напрямую.
        
- **Важная мысль:** равенство должно отражать смысл этого типа. Не включай в сравнении “временные” поля.
    

## Почему equals и hashCode нужно переопределять вместе

#### Контракт

- **Правило:** Если `equals` говорит “равны”, `hashCode` обязан возвращать одинаковое значение. Иначе хеш-коллекции начнут вести себя странно (не найдут элемент по ключу, дубли в `HashSet`).
    
- **Обратное:** разные объекты могут иметь одинаковые `hashCode`, но это ухудшает производительность, а не корректность.
    

> Пример: два объекта-ключа в `HashMap` равны по `equals`, но `hashCode` у них разный — при поиске по ключу ты не найдёшь запись.

## equals для класса со String или StringBuilder

#### Вариант со String

java

```
class S {
    private final String value;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof S)) return false;
        S other = (S) o;
        return value != null ? value.equals(other.value) : other.value == null;
    }

    @Override
    public int hashCode() {
        return value != null ? value.hashCode() : 0;
    }
}
```

#### Вариант со StringBuilder

- **Проблема:** `StringBuilder` не переопределяет `equals` — у него `equals` как у `Object` (сравнение по ссылке).
    
- **Решение:** сравнивай по содержимому через `toString()` или вручную по символам.
    

java

```
class SB {
    private final StringBuilder sb;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SB)) return false;
        SB other = (SB) o;
        String a = sb == null ? null : sb.toString();
        String b = other.sb == null ? null : other.sb.toString();
        return a != null ? a.equals(b) : b == null;
    }

    @Override
    public int hashCode() {
        return sb == null ? 0 : sb.toString().hashCode();
    }
}
```

## Правила hashCode() и что будет, если вернуть константу

#### Правильные правила

- **Консистентность:** не меняется, пока объект логически не изменился.
    
- **Совместимость с equals:** равные объекты → одинаковый `hashCode`.
    
- **Распределение:** желательно разные хеши для разных объектов (меньше коллизий).
    

#### Можно ли вернуть константу?

- **Можно, но плохо:** корректность не нарушается, но производительность хеш-структур резко падает (все элементы в одной корзине → линейный поиск).
    
- **Как делать хорошо:** комбинировать хеши полей. Пример:
    

java

```
@Override
public int hashCode() {
    int result = 17;               // произвольное ненулевое
    result = 31 * result + (name == null ? 0 : name.hashCode());
    result = 31 * result + age;
    return result;
}
```

- **Почему 31:** простое число, хорошо распределяет и быстро считается (умножение на 31 = сдвиг и вычитание).
    

## Правила clone() и как правильно копировать

#### Базовые правила

- **Интерфейс Cloneable:** должен быть реализован, иначе `CloneNotSupportedException`.
    
- **Поверхностная копия:** копируются поля, но если поле — объект, то копируется ссылка (делят общее состояние).
    
- **Глубокая копия:** вручную клонируем/копируем внутренние объекты.
    

#### Практика

java

```
class Person implements Cloneable {
    String name;
    Address address; // сложный объект

    @Override
    protected Person clone() throws CloneNotSupportedException {
        Person p = (Person) super.clone(); // поверхностная копия
        p.address = address.clone();       // глубокая копия (если Address тоже Cloneable)
        return p;
    }
}
```

> Альтернатива: писать копирующий конструктор или фабричный метод `copyOf()`. Это часто чище, чем `clone()`.

## finally, finalize и ключевое слово final

#### finally

- **Что это:** блок в `try-catch`, который выполняется всегда, даже если было исключение. Обычно закрывают ресурсы (`close()`).
    
- **Современная альтернатива:** `try-with-resources` автоматически закрывает ресурсы.
    ## Когда `finally` не вызовется

### 1. **Принудительное завершение JVM**

- Если процесс завершается "жёстко":
    
    - `System.exit(...)`
        
    - `Runtime.getRuntime().halt(...)`
        
    - Убийство процесса извне (kill -9 в Linux, завершение через Task Manager).
        
- В этих случаях **JVM не даёт шанса** выполнить `finally`.
    

### 2. **Аппаратные ошибки**

- Ошибки уровня JVM/OS:
    
    - `OutOfMemoryError` в критическом месте.
        
    - Ошибки нативного кода (например, `StackOverflowError` в бесконечной рекурсии).
        
    - Сегфолты при работе с JNI.
        
- JVM может аварийно завершиться → `finally` не выполнится.
### 3. **Демон-потоки**

- Если поток помечен как `daemon`, он может быть прерван при завершении JVM **без гарантии выполнения** `finally`.
    
- Пример: если все пользовательские потоки завершились, JVM завершает работу и может оборвать демоны.
    

### 4. **Thread.stop() (устаревший метод)**

- Если вызвать `Thread.stop()`, поток может быть прерван **без корректного завершения try/finally**.
    
- Этот метод давно признан небезопасным и не рекомендуется.
    

### 5. **Аппаратное выключение**

- Выключение компьютера, падение питания, аварийный рестарт ОС.
    
- Очевидно, никакой `finally` не успеет выполниться.

#### finalize

- **Что это:** метод, который когда-то мог вызываться сборщиком мусора перед удалением объекта. Ненадёжный, устарел, может вообще не вызываться. Не использовать.
    

#### final

- **Для переменных:** нельзя переназначить ссылку/значение. Для ссылок — делает неизменной ссылку, но не объект, на который она указывает.
    
- **Для методов:** нельзя переопределить.
    
- **Для классов:** нельзя наследовать (например, `String`).
    

## JavaBeans: требования и зачем они нужны

#### Требования

- **Публичный класс** с **пустым конструктором**.
    
- **Приватные поля**.
    
- **Геттеры/сеттеры** по соглашению: `getX()`, `setX(value)`, для логических — `isX()`.
    
- **Сериализуемость** (часто): реализовать `Serializable`, если нужно сохранять/передавать.
    

#### Зачем

- **Фреймворки** (Spring, JSF, старые Java EE), инструменты и библиотеки могут автоматически создавать, заполнять и валидировать такие объекты, опираясь на соглашения имён.
    

## Garbage Collector: как работает и какие алгоритмы

#### Общая идея

- **Автоматическая очистка:** GC находит объекты, на которые больше нет достижимых ссылок, и освобождает память.
    
- **Корни (GC roots):** откуда начинает поиск: стеки потоков, статические поля, JNI-ссылки.
    

#### Типовые алгоритмы

- **Mark-and-Sweep:** пометить живые, очистить мёртвые.
    
- **Copying:** скопировать живые из одной области в другую, старую область целиком очистить.
    
- **Generational GC:** деление кучи на поколения: молодое (частые паузы, быстро умирают) и старое (реже). Часто используется комбинация.
    

#### Можно ли удалить объект вручную?

- **Нет:** нельзя указать GC удалить конкретный объект. Можно только убрать на него все ссылки.
    
- `System.gc()` — лишь намёк GC, не гарантия.
    

## Где что хранится: стек, куча, метаданные, строки

- **Stack (стек):** локальные переменные методов (примитивы), ссылки на объекты; живёт в рамках потока. Очень быстрый, но короткоживущий.
    
- **Heap (куча):** все объекты, массивы, строки; память управляется GC. Общая для всех потоков.
    
- **Metaspace:** метаданные классов, структуры, связанные с загрузкой классов (раньше PermGen).
    
- **String Pool:** специализированное место в куче для строк-литералов и интернированных строк.
    

> Важный нюанс: примитивы внутри объектов хранятся в куче как часть объекта. Локальные примитивы — в стеке.

## Поля интерфейса: что у них по умолчанию

- **По умолчанию всегда:** `public static final`. Это константы, и ты обязан сразу инициализировать их.
    

java

```
interface Config {
    int TIMEOUT_MS = 1000; // публичная статическая константа
}
```

- **Почему так:** интерфейсы — про контракт поведения; хранить изменяемое состояние там нельзя.
    

## Ассоциации, агрегация и композиция

- **Ассоциация:** просто связь между объектами (учитель преподаёт ученику).
    
- **Агрегация:** “имеет” слабо — ребёнок может жить без родителя (класс `Team` содержит список `Player`, но игрок может существовать отдельно).
    
- **Композиция:** “состоит из” сильно — часть живёт и умирает вместе с целым (дом и его комнаты: без дома комнаты не существуют самостоятельно).
    

> На собеседовании спросить могут: “Приведи пример композиции в коде” — класс владеет объектом, создаёт его внутри и не отдаёт наружу без контроля.

## Абстрактный класс и интерфейс: отличия

- **Абстрактный класс:**
    
    - Может иметь состояние (поля), конструкторы.
        
    - Может содержать как реализованные, так и абстрактные методы.
        
    - Один родитель (Java — без множественного наследования классов).
        
- **Интерфейс:**
    
    - Описывает только контракт. Поля — только `public static final`.
        
    - С Java 8 может иметь `default` и `static` методы (реализация по умолчанию).
        
    - Реализаций может быть много (класс может реализовать несколько интерфейсов).
        

> Правильная мысль: интерфейс — обещание поведения; абстрактный класс — частичная готовая реализация с общим кодом и состоянием.

## Когда использовать интерфейс, а когда абстрактный класс
интерфейс для действий абстрактный для сущности
- **Интерфейс — логичнее, когда:**
    
    - Нужен общий контракт для разных иерархий.
        
    - Хочешь позволить множественную “наследственность” (один класс может реализовать несколько интерфейсов).
        
    - Нет общего состояния.
        
- **Абстрактный класс — логичнее, когда:**
    
    - Есть общее состояние (поля) и базовая реализация.
        
    - Нужно защитить от несовместимых реализаций (даёшь скелет).
        
    - Внутри есть защищённые утилиты и шаблонные методы.
        

> Пример: `AbstractList` даёт базовую логику списков, а `List` — интерфейс, который описывает контракт.

## Интерфейсы без методов — “маркерные”

- **Суть:** интерфейс не содержит методов; сам факт его реализации что-то означает для системы.
    
- **Примеры:** `Serializable`, `Cloneable`.
    
- **Зачем:** фреймворки/среда через `instanceof` узнают, можно ли применять особое поведение (например, сериализовать).
    

## Перегрузка и переопределение: модификатор доступа

- **Переопределение (override):** в подклассе меняем реализацию метода родителя.
    
    - **Можно** расширять доступ: `protected` → `public`.
        
    - **Нельзя** сужать: `public` → `protected/private` (нарушает контракт).
        
- **Перегрузка (overload):** в одном классе несколько методов с одним именем, но разными параметрами.
    
    - Модификатор доступа может быть любым, не влияет на перегрузку.
        

## Перегрузка и переопределение: возвращаемый тип и параметры

- **Переопределение:**
    
    - **Параметры:** должны совпадать по сигнатуре (имена не важны).
        
    - **Возвращаемый тип:** может быть ковариантным — более специфичным подтипом оригинального (например, `Object` → `String` нельзя, но `Animal` → `Dog` можно).
        
- **Перегрузка:**
    
    - **Параметры:** меняем тип/количество/порядок (компилятор различает по сигнатуре).
        
    - **Возвращаемый тип:** можно менять, но сам по себе он не различает перегрузку — нужен отличающийся список параметров.
        

> Важная ловушка: автобоксинг и varargs могут вызывать неоднозначность перегрузки — знай приоритеты (точное совпадение типов > примитивы > боксинг > varargs).

## 38. Можно ли менять возвращаемый тип метода и тип параметров?

- **Перегрузка**: можно менять параметры (количество, тип). Возвращаемый тип может быть любым.
    
- **Переопределение**: возвращаемый тип можно менять только на совместимый (например, родительский метод возвращает `Animal`, а дочерний — `Dog`). Параметры менять нельзя.
    

## 39. Каким образом передаются переменные в методы?

- В Java всё передаётся **по значению**.
    
- Но если это объект, то передаётся значение **ссылки**. То есть метод получает копию адреса объекта, и может менять сам объект, но не ссылку.
    

## 40. Что такое конструктор по умолчанию?

- Это специальный метод, который создаёт объект.
    
- Если мы не написали свой конструктор, Java автоматически создаёт пустой конструктор без параметров.
    

## 41. Свойства конструктора. Способы его вызова.

- Конструктор:
    
    - имеет то же имя, что и класс,
        
    - не возвращает значение,
        
    - вызывается при создании объекта через `new`.
        
- Пример:
    
    java
    
    ```
    class Car {
        Car() { // конструктор
            System.out.println("Car created!");
        }
    }
    
    Car c = new Car(); // вызов конструктора
    ```
    

## 42. Mutable и Immutable классы.

- **Mutable (изменяемые)** — объект можно менять. Пример: `ArrayList`.
    
- **Immutable (неизменяемые)** — объект нельзя менять после создания. Пример: `String`.
    
- Чтобы создать immutable-класс:
    
    - сделать поля `private final`,
        
    - не давать сеттеров,
        
    - возвращать копии коллекций.
        
- В Java есть специальный тип — **record**, который автоматически создаёт immutable-класс:
    
    java
    
    ```
    record Point(int x, int y) {}
    ```
    

## 43. static — что это?

- `static` означает, что поле или метод принадлежит классу, а не объекту.
    
- Если изменить `static` поле через один объект, оно изменится для всех.
    
- Пример:
    
    java
    
    ```
    class Counter {
        static int count = 0;
    }
    
    Counter c1 = new Counter();
    Counter c2 = new Counter();
    c1.count = 5;
    System.out.println(c2.count); // будет 5
    ```
    

## 44. Может ли статический метод быть перегружен или переопределён?

- **Перегружен** — да, можно создать несколько статических методов с одинаковым именем, но разными параметрами.
    
- **Переопределён** — нет, статические методы принадлежат классу, а не объекту. Их можно **скрыть** (hide), но это не настоящее переопределение.

# Внутренние классы в Java

Внутренние классы помогают логически группировать код, инкапсулировать детали реализации и работать с окружением внешнего класса. Их четыре вида: member (нестатический), static nested, local, anonymous.

## Виды внутренних классов и цели использования

- **Нестатический внутренний класс (member inner class):** Живет внутри внешнего класса, привязан к экземпляру внешнего.
    
    - **Цели:** Инкапсуляция деталей, тесно связанных с состоянием внешнего объекта; доступ к приватным полям внешнего класса.
        
    - **Особенности:** Имеет неявную ссылку `Outer.this`; не может иметь статических членов (кроме констант).
        
    - **Пример:**
        
    
    java
    
    ```
    class Outer {
        private int state = 42;
        class Inner {
            int doubleOuter() { return state * 2; } // доступ к private
        }
    }
    ```
    
- **Статический вложенный класс (static nested class):** Статический член внешнего класса.
    
    - **Цели:** Логическая группировка, когда связь с внешним классом концептуальная, но не нужна ссылка на экземпляр.
        
    - **Особенности:** Не имеет ссылки на `Outer.this`; может иметь статические члены.
        
    - **Пример:**
        
    
    java
    
    ```
    class Outer {
        static class Nested {
            static int util(int x) { return x * x; }
        }
    }
    ```
    
- **Локальный класс (local class):** Объявляется внутри блока (метод, конструктор, инициализатор).
    
    - **Цели:** Вспомогательная логика рядом с использованием, скрытая от остального кода.
        
    - **Особенности:** Доступ к переменным метода, если они «эффективно final»; не виден вне блока.
        
    - **Пример:**
        
    
    java
    
    ```
    void process() {
        int base = 10; // эффективно final
        class Worker {
            int run(int x) { return base + x; }
        }
        System.out.println(new Worker().run(5));
    }
    ```
    
- **Анонимный класс (anonymous class):**  4 вида анонимных классов
- Без имени; однократное расширение класса или реализация интерфейса.
    
    - **Цели:** Быстрое определение поведения «на месте», особенно для коллбеков и стратегий.
        
    - **Особенности:** Один класс/интерфейс в заголовке; нет конструктора с именем; нельзя иметь статические объявления (кроме констант).
        
    - **Пример:**
        
    
    java
    
    ```
    Runnable r = new Runnable() {
        @Override public void run() { System.out.println("Hi"); }
    };
    ```
    

## Области видимости и доступ к данным

- **Доступ из inner к outer:**
    
    - **Правило:** Внутренние классы (включая локальные и анонимные) имеют доступ ко всем членам внешнего класса, включая `private`.
        
    - **Явное указание внешнего:** `Outer.this.field` и `Outer.this.method()` — когда есть теневание имен.
        
- **Доступ outer к inner:**
    
    - **Правило:** Требуется экземпляр внутреннего:
        
    
    java
    
    ```
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    ```
    
- **Локальный/анонимный к переменным метода:**
    
    - **Правило:** Можно читать только «эффективно final» переменные (значение не изменяется после присвоения). Это связано с копированием значения в скрытое поле при компиляции.
        
- **Статический вложенный класс:**
    
    - **Правило:** Не имеет доступа к нестатическим членам внешнего класса без явного экземпляра.
        
- **Теневание (shadowing):**
    
    - **Правило:** Если имя поля совпадает, приоритет у ближайшей области. Для доступа к внешнему используйте `Outer.this.field`.
        

# Анонимные классы: применение и ограничения

- **Практическое применение:**
    
    - **Коллбеки/слушатели событий:** До появления лямбд — `ActionListener`, `Runnable`, `Callable`.
        
    - **Стратегии и адаптеры:** Разовые реализации `Comparator`, `InputStream`, «обертки» для тестов.
        
    - **Контекстно-зависимое поведение:** Временная модификация поведения при передаче в методы.
        
- **Когда нельзя создать анонимный класс:**
    
    - **От final-класса:** Нельзя наследовать от `final` (например, `String`, `Integer`).
        
    - **От enum, record или annotation:** Нельзя анонимно расширять `enum`, `record`, `@interface`.
        
    - **Для примитивов и массивов:** Только классы/интерфейсы подходят.
        
    - **С несколькими родителями:** Анонимный класс может расширять только один класс или реализовать один интерфейс в объявлении; для нескольких интерфейсов используйте именованный класс.
        
    - **Когда нужен именованный конструктор:** У анонимного класса нет имени конструктора; можно лишь использовать «инициализатор» блока.
        
- **Совет:** В современном Java предпочтительнее лямбды, если вы реализуете функциональные интерфейсы (один абстрактный метод). Анонимные классы — для случаев, где нужно состояние, дополнительные методы или реализация не функционального интерфейса.
    

# Generics: назначение, стирание типов и wildcards

- **Что это и для чего:**
    
    - **Типобезопасность:** Переносят ошибки типов на компиляцию (например, `List<String>`).
        
    - **Самодокументация:** Делают API явным по типам.
        
    - **Устранение cast-ов:** Нет необходимости в приведениях при чтении.
        
- **Во что превращается при компиляции и выполнении (type erasure):**
    
    - **Компиляция:** Проверяются типовые ограничения, добавляются приведения и мостовые методы.
        
    - **Стирание:** Параметры типов стираются до верхней границы (обычно `Object` или указанного bound), поэтому в рантайме `List<String>` и `List<Integer>` — один класс `java.util.ArrayList`.
        
    - **Следствия:**
        
        - Нельзя `new T()`, нельзя `T.class`, нельзя создавать массивы параметризованных типов: `new List<String>[10]` — нельзя.
            
        - Перегрузка по параметрам типов не работает, отражение не видит различий параметризаций.
            
        - Проверка `instanceof List<String>` невозможна; только `instanceof List`.
            
- **Wildcards (**`?`**):**
    
    - `? extends T`**:** «Читатель». Можно читать как `T`, добавлять нельзя (кроме `null`).
        
        - Пример: источники данных `List<? extends Number>`.
            
    - `? super T`**:** «Писатель». Можно класть `T` и его подтипы, читать безопасно только как `Object`.
        
        - Пример: цели для записи `List<? super Integer>`.
            
    - **Правило PECS:** Producer Extends, Consumer Super.
        
- **Bounded type parameters:**
    
    - **Ограничения:** `<T extends Number & Comparable<T>>` — верхние границы классов и интерфейсов.
        
    - **Пример:**
        
    
    java
    
    ```
    static <T extends Comparable<T>> T max(List<T> list) {
        T best = list.get(0);
        for (T t : list) if (t.compareTo(best) > 0) best = t;
        return best;
    }
    ```
    
- **Частые ошибки:**
    
    - **Инвариантность:** `List<Integer>` не является `List<Number>`. Используйте `List<? extends Number>`.
        
    - **Массивы ковариантны, generics — нет:** Arrays допускают runtime-ошибки, generics — compile-time проверку.
        
    - **Raw types:** Избегайте `List` без параметров — теряете типобезопасность.
        

# Enum: назначение, применение и ошибки использования

- **Что такое enum:**
    
    - **Перечисление конечного набора констант:** Каждая константа — экземпляр класса `Enum`-типа; можно добавлять поля, методы, конструкторы (всегда `private`).
        
    - **Пример:**
        
    
    java
    
    ```
    enum Status {
        NEW, IN_PROGRESS, DONE;
    }
    ```
    
- **Применение:**
    
    - **Доменные состояния:** Статусы заказов, роли, типы операций.
        
    - **Поведение по константе:** Переключение `switch`, стратегия через переопределение методов константами.
        
    - **Инструменты:** `EnumSet`, `EnumMap` — эффективные структуры для enum-ключей.
        
- **Расширенные возможности:**
    
    java
    
    ```
    enum Operation {
        PLUS { double apply(double a, double b) { return a + b; } },
        MINUS{ double apply(double a, double b) { return a - b; } };
        abstract double apply(double a, double b);
    }
    ```
    
- **Некорректное использование:**
    
    - **Динамические данные:** Enum не для сущностей, список которых меняется в рантайме (например, значения из БД).
        
    - **Слишком много mutable-состояния:** Мутируемые поля в enum приводят к shared mutable state (один экземпляр на константу) — опасно для потоков.
        
    - **Перегрузка бизнес-логики:** Огромные `switch` по enum вместо полиморфизма или стратегий.
        
    - **Сериализация внешних значений:** Привязка к `ordinal()` хрупка; используйте стабильные `name()` или явные коды.
        
    - **Антипаттерн «enum как конфиг»:** Хранить пользовательские настройки/внешние ресурсы в enum — делает их негибкими.
        

# Отличия Comparator и Comparable

|Атрибут|Comparable|Comparator|
|---|---|---|
|Где определяется|Внутри класса объекта|В отдельном классе/лямбде|
|Интерфейс|`int compareTo(T o)`|`int compare(T a, T b)`|
|Кол-во порядков|Один «естественный» порядок|Сколько угодно различных порядков|
|Использование|`Collections.sort(list)` если T implements Comparable|Передается явным параметром: `sort(list, comparator)`|
|Гибкость|Низкая: жестко зашит в тип|Высокая: легко менять критерии|

> Sources: интерфейсы стандартной библиотеки Java

- **Рекомендации:**
    
    - **Comparable:** Когда есть естественный порядок (например, `LocalDate`, `BigDecimal`).
        
    - **Comparator:** Когда порядок зависит от контекста (по цене, по имени, по нескольким полям) или нельзя/не хотите менять тип.
        
- **Примеры:**
    
    java
    
    ```
    class Person implements Comparable<Person> {
        String name; int age;
        @Override public int compareTo(Person o) {
            return name.compareTo(o.name); // естественный порядок: по имени
        }
    }
    
    Comparator<Person> byAgeDesc = Comparator.comparingInt(p -> p.age).reversed();
    ```
    

# Optional: борьба с null, хорошие и плохие практики

- **Зачем нужен Optional:**
    
    - **Явно выражает «может не быть» в возвращаемом значении.**
        
    - **Устраняет** `NullPointerException`**-паттерны:** Предлагает композицию операций (`map`, `flatMap`, `filter`, `orElseGet`) вместо `if (x != null)`.
        
- **Хорошее использование:**
    
    - **Возврат из репозиториев/поиска:**
        
    
    java
    
    ```
    Optional<User> findById(String id) { ... }
    
    String email = findById("42")
        .map(User::getProfile)
        .map(Profile::getEmail)
        .filter(e -> e.contains("@"))
        .orElse("unknown@example.com");
    ```
    
    - **Преобразования без NPE:** Чистая композиция без явных null-проверок.
        
- **Некорректное использование:**
    
    - **В полях сущностей и параметрах методов:** `Optional` предназначен для возвращаемых значений; поля/параметры усложняют модель и расходуют память.
        
    - **Коллекции** `Optional`**:** `List<Optional<T>>` почти всегда признак плохого дизайна — используйте просто `List<T>` и фильтрацию.
        
    - `get()` **без проверки:** Бросит `NoSuchElementException`; используйте `orElse`, `orElseGet`, `orElseThrow`.
        
    - `orElse` **с тяжелыми вычислениями:** Аргумент вычисляется всегда. Предпочитайте `orElseGet(() -> heavy())`.
        
    - **Сериализация/DTO:** Опционал — логика, а не данные; в DTO лучше явные nullable-поля или отдельные типы.
        

# Принципы SOLID, YAGNI, KISS, DRY

- **S (Single Responsibility):**
    
    - **Идея:** Один класс — одна причина для изменения.
        
    - **Практика:** Разделяйте логику: валидаторы, конвертеры, сервисы, репозитории — отдельно.
        
- **O (Open/Closed):**
    
    - **Идея:** Расширяемость без модификации существующего кода.
        
    - **Практика:** Интерфейсы, стратегии, шаблоны (Factory, Strategy), enum c поведением.
        
- **L (Liskov Substitution):**
    
    - **Идея:** Подтип должен быть взаимозаменяем с базовым без сюрпризов.
        
    - **Практика:** Не ослабляйте постусловия, не усиливайте предусловия; избегайте неожиданных исключений.
        
- **I (Interface Segregation):**
    
    - **Идея:** Мелкие целевые интерфейсы лучше, чем «толстые».
        
    - **Практика:** Не заставляйте имплементаторов реализовывать ненужные методы.
        
- **D (Dependency Inversion):**
    
    - **Идея:** Зависимости — от абстракций, а не от реализаций.
        
    - **Практика:** Внедрение зависимостей, фабрики, события; модули общаются через интерфейсы.
        
- **YAGNI (You Aren’t Gonna Need It):**
    
    - **Идея:** Не реализуй, пока не нужен.
        
    - **Практика:** Минимизируйте «на будущее», пишите по требованиям.
        
- **KISS (Keep It Simple, Stupid):**
    
    - **Идея:** Простые решения более надежны.
        
    - **Практика:** Избегайте ненужной абстракции; понятный код важнее трюков.
        
- **DRY (Don’t Repeat Yourself):**
    
    - **Идея:** Одна истина в одном месте.
        
    - **Практика:** Общие утилиты, переиспользуемые компоненты; не дублируйте бизнес-правила.
        

# Вызов метода не из интерфейса/абстрактного базового типа

- **Сценарий:**
    
    java
    
    ```
    interface Interf { /* no method() */ }
    class Clazz implements Interf {
        void method() { System.out.println("X"); }
    }
    Interf a = new Clazz();
    a.method(); // ?
    ```
    
- **Ответ:** Некорректно. Компиляция ошибется: метод `method()` не объявлен в `Interf`.
    
    - **Как правильно:** Либо объявите метод в интерфейсе (включая `default`), либо приведите тип:
        
    
    java
    
    ```
    ((Clazz) a).method(); // безопасно только если точно Clazz
    ```
    
- **То же с абстрактным классом:** Правило идентично. Вызываемые методы должны быть объявлены в статическом типе ссылки.
    

# ClassLoader, статика и синглтоны

- **Что такое ClassLoader:**
    
    - **Механизм загрузки классов в JVM:** Отвечает за поиск байткода, преобразование в `Class`, изоляцию модулей/приложений.
        
    - **Модель делегации:** Обычно родительская делегация (bootstrap → platform → application). Можно делать кастомные лоадеры для плагинов.
        
- **Статические переменные между разными ClassLoader-ами:**
    
    - **Правило:** Класс, загруженный разными лоадерами, считается разными типами. Статика хранится отдельно в каждом загрузчике.
        
    - **Следствие:** Изменение `static` в одном ClassLoader не видно экземпляру того же класса, загруженному другим.
        
- **Синглтоны и ClassLoader:**
    
    - **Правило:** «Один» — на ClassLoader. Если один и тот же класс загружен несколькими лоадерами, будет несколько независимых синглтонов.
        
    - **Практика:** В серверах приложений, OSGi, плагинных системах — учитывайте границы ClassLoader-ов. Для глобальной уникальности используйте внешнее хранилище (процесс- или системного уровня), либо сервис-локатор/DI-контейнер на уровне корневого лоадера.
        
- **Мини-демо:**
    
    java
    
    ```
    // Псевдо: два лоадера загружают один и тот же класс синглтона
    Class<?> c1 = loaderA.loadClass("com.example.Singleton");
    Class<?> c2 = loaderB.loadClass("com.example.Singleton");
    Object s1 = c1.getMethod("getInstance").invoke(null);
    Object s2 = c2.getMethod("getInstance").invoke(null);
    System.out.println(s1 == s2); // false: разные классы/лоадеры
```