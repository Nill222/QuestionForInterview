## Важно Базовый класс Object и его методы

#### Зачем нужен Object

- **Идея:** В Java все классы в итоге происходят от одного общего предка — `java.lang.Object`. Это даёт единый набор базовых возможностей для каждого объекта.
    
- **Почему так:** Это упрощает работу коллекций, сравнения объектов, превращение их в строки, синхронизацию потоков и т.д.
    

#### Ключевые методы и простыми словами, зачем они

- **equals(Object o):** логическое равенство объектов по содержимому. По умолчанию сравнивает ссылки (т.е. одинаковые ли объекты в памяти).
    
- **hashCode():** числовая “подпись” объекта для быстрых структур данных (например, `HashMap`). Связан с `equals`.
    
- **toString():** “человеческое” строковое представление объекта. Полезно для логов и отладки.
    
- **getClass():** возвращает класс объекта во время выполнения (рефлексия).
    
- **clone():** создать копию объекта (поверхностно, если не переопределено).
    
- **finalize():** вызывался сборщиком мусора перед удалением объекта; устарел и не рекомендуется.
    
- **wait()/notify()/notifyAll():** средства синхронизации потоков на уровне объекта (при работе с `synchronized`).
    
- **Пример:** Когда ты кладёшь объект в `HashSet`, он использует `hashCode` для корзины, а затем `equals`, чтобы понять, равен ли объект уже существующему.
    

## Важно Абстракция и четыре принципа ООП

#### Абстракция

- **Смысл:** Скрыть реализацию и оставить только важный интерфейс взаимодействия. Например, коллекция позволяет добавлять элементы, но скрывает детали хранения.
    
- **Инструменты:** интерфейсы, абстрактные классы, сокрытие полей.
    

#### Четыре столпа ООП

- **Инкапсуляция:** скрываем поля (private), открываем безопасные методы (get/set). Защищает от неправильного использования.
    
- **Наследование:** берём общий базовый класс и расширяем/уточняем. Экономит код, но может усложнить зависимость.
    
- **Полиморфизм:** один интерфейс — разные реализации. Позволяет писать код “против” абстракций.
    
- **Абстракция:** выделяем существенное, убираем детали. Снижает сложность.
    

> Пример: У тебя есть интерфейс `List`. Он абстрактен; конкретные реализации `ArrayList` и `LinkedList` разные внутри, но снаружи — один контракт.

## Правила equals(Object o) и почему они важны

#### Контракт equals — 5 свойств

- **Рефлексивность:** объект равен сам себе.
    
- **Симметричность:** если A равен B, то B равен A.
    
- **Транзитивность:** если A равен B и B равен C, то A равен C.
    
- **Консистентность:** результат не меняется, если объект не менялся.
    
- **С null:** любой объект не равен `null`.
    

#### Практическая реализация

- **Шаги:**
    
    - Сравнить ссылки: `if (this == o) return true;`
        
    - Проверить `null`: `if (o == null) return false;`
        
    - Проверить тип: `if (getClass() != o.getClass()) return false;` или `instanceof` если допускаешь наследников.
        
    - Сравнить значимые поля: для объектов — через их `equals`, для примитивов — напрямую.
        
- **Важная мысль:** равенство должно отражать смысл этого типа. Не включай в сравнении “временные” поля.
    

## Почему equals и hashCode нужно переопределять вместе

#### Контракт

- **Правило:** Если `equals` говорит “равны”, `hashCode` обязан возвращать одинаковое значение. Иначе хеш-коллекции начнут вести себя странно (не найдут элемент по ключу, дубли в `HashSet`).
    
- **Обратное:** разные объекты могут иметь одинаковые `hashCode`, но это ухудшает производительность, а не корректность.
    

> Пример: два объекта-ключа в `HashMap` равны по `equals`, но `hashCode` у них разный — при поиске по ключу ты не найдёшь запись.

## equals для класса со String или StringBuilder

#### Вариант со String

java

```
class S {
    private final String value;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof S)) return false;
        S other = (S) o;
        return value != null ? value.equals(other.value) : other.value == null;
    }

    @Override
    public int hashCode() {
        return value != null ? value.hashCode() : 0;
    }
}
```

#### Вариант со StringBuilder

- **Проблема:** `StringBuilder` не переопределяет `equals` — у него `equals` как у `Object` (сравнение по ссылке).
    
- **Решение:** сравнивай по содержимому через `toString()` или вручную по символам.
    

java

```
class SB {
    private final StringBuilder sb;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SB)) return false;
        SB other = (SB) o;
        String a = sb == null ? null : sb.toString();
        String b = other.sb == null ? null : other.sb.toString();
        return a != null ? a.equals(b) : b == null;
    }

    @Override
    public int hashCode() {
        return sb == null ? 0 : sb.toString().hashCode();
    }
}
```

## Правила hashCode() и что будет, если вернуть константу

#### Правильные правила

- **Консистентность:** не меняется, пока объект логически не изменился.
    
- **Совместимость с equals:** равные объекты → одинаковый `hashCode`.
    
- **Распределение:** желательно разные хеши для разных объектов (меньше коллизий).
    

#### Можно ли вернуть константу?

- **Можно, но плохо:** корректность не нарушается, но производительность хеш-структур резко падает (все элементы в одной корзине → линейный поиск).
    
- **Как делать хорошо:** комбинировать хеши полей. Пример:
    

java

```
@Override
public int hashCode() {
    int result = 17;               // произвольное ненулевое
    result = 31 * result + (name == null ? 0 : name.hashCode());
    result = 31 * result + age;
    return result;
}
```

- **Почему 31:** простое число, хорошо распределяет и быстро считается (умножение на 31 = сдвиг и вычитание).
    

## Правила clone() и как правильно копировать

#### Базовые правила

- **Интерфейс Cloneable:** должен быть реализован, иначе `CloneNotSupportedException`.
    
- **Поверхностная копия:** копируются поля, но если поле — объект, то копируется ссылка (делят общее состояние).
    
- **Глубокая копия:** вручную клонируем/копируем внутренние объекты.
    

#### Практика

java

```
class Person implements Cloneable {
    String name;
    Address address; // сложный объект

    @Override
    protected Person clone() throws CloneNotSupportedException {
        Person p = (Person) super.clone(); // поверхностная копия
        p.address = address.clone();       // глубокая копия (если Address тоже Cloneable)
        return p;
    }
}
```

> Альтернатива: писать копирующий конструктор или фабричный метод `copyOf()`. Это часто чище, чем `clone()`.

## finally, finalize и ключевое слово final

#### finally

- **Что это:** блок в `try-catch`, который выполняется всегда, даже если было исключение. Обычно закрывают ресурсы (`close()`).
    
- **Современная альтернатива:** `try-with-resources` автоматически закрывает ресурсы.
    

#### finalize

- **Что это:** метод, который когда-то мог вызываться сборщиком мусора перед удалением объекта. Ненадёжный, устарел, может вообще не вызываться. Не использовать.
    

#### final

- **Для переменных:** нельзя переназначить ссылку/значение. Для ссылок — делает неизменной ссылку, но не объект, на который она указывает.
    
- **Для методов:** нельзя переопределить.
    
- **Для классов:** нельзя наследовать (например, `String`).
    

## JavaBeans: требования и зачем они нужны

#### Требования

- **Публичный класс** с **пустым конструктором**.
    
- **Приватные поля**.
    
- **Геттеры/сеттеры** по соглашению: `getX()`, `setX(value)`, для логических — `isX()`.
    
- **Сериализуемость** (часто): реализовать `Serializable`, если нужно сохранять/передавать.
    

#### Зачем

- **Фреймворки** (Spring, JSF, старые Java EE), инструменты и библиотеки могут автоматически создавать, заполнять и валидировать такие объекты, опираясь на соглашения имён.
    

## Garbage Collector: как работает и какие алгоритмы

#### Общая идея

- **Автоматическая очистка:** GC находит объекты, на которые больше нет достижимых ссылок, и освобождает память.
    
- **Корни (GC roots):** откуда начинает поиск: стеки потоков, статические поля, JNI-ссылки.
    

#### Типовые алгоритмы

- **Mark-and-Sweep:** пометить живые, очистить мёртвые.
    
- **Copying:** скопировать живые из одной области в другую, старую область целиком очистить.
    
- **Generational GC:** деление кучи на поколения: молодое (частые паузы, быстро умирают) и старое (реже). Часто используется комбинация.
    

#### Можно ли удалить объект вручную?

- **Нет:** нельзя указать GC удалить конкретный объект. Можно только убрать на него все ссылки.
    
- `System.gc()` — лишь намёк GC, не гарантия.
    

## Где что хранится: стек, куча, метаданные, строки

- **Stack (стек):** локальные переменные методов (примитивы), ссылки на объекты; живёт в рамках потока. Очень быстрый, но короткоживущий.
    
- **Heap (куча):** все объекты, массивы, строки; память управляется GC. Общая для всех потоков.
    
- **Metaspace:** метаданные классов, структуры, связанные с загрузкой классов (раньше PermGen).
    
- **String Pool:** специализированное место в куче для строк-литералов и интернированных строк.
    

> Важный нюанс: примитивы внутри объектов хранятся в куче как часть объекта. Локальные примитивы — в стеке.

## Поля интерфейса: что у них по умолчанию

- **По умолчанию всегда:** `public static final`. Это константы, и ты обязан сразу инициализировать их.
    

java

```
interface Config {
    int TIMEOUT_MS = 1000; // публичная статическая константа
}
```

- **Почему так:** интерфейсы — про контракт поведения; хранить изменяемое состояние там нельзя.
    

## Ассоциации, агрегация и композиция

- **Ассоциация:** просто связь между объектами (учитель преподаёт ученику).
    
- **Агрегация:** “имеет” слабо — ребёнок может жить без родителя (класс `Team` содержит список `Player`, но игрок может существовать отдельно).
    
- **Композиция:** “состоит из” сильно — часть живёт и умирает вместе с целым (дом и его комнаты: без дома комнаты не существуют самостоятельно).
    

> На собеседовании спросить могут: “Приведи пример композиции в коде” — класс владеет объектом, создаёт его внутри и не отдаёт наружу без контроля.

## Абстрактный класс и интерфейс: отличия

- **Абстрактный класс:**
    
    - Может иметь состояние (поля), конструкторы.
        
    - Может содержать как реализованные, так и абстрактные методы.
        
    - Один родитель (Java — без множественного наследования классов).
        
- **Интерфейс:**
    
    - Описывает только контракт. Поля — только `public static final`.
        
    - С Java 8 может иметь `default` и `static` методы (реализация по умолчанию).
        
    - Реализаций может быть много (класс может реализовать несколько интерфейсов).
        

> Правильная мысль: интерфейс — обещание поведения; абстрактный класс — частичная готовая реализация с общим кодом и состоянием.

## Когда использовать интерфейс, а когда абстрактный класс
интерфейс для действий абстрактный для сущности
- **Интерфейс — логичнее, когда:**
    
    - Нужен общий контракт для разных иерархий.
        
    - Хочешь позволить множественную “наследственность” (один класс может реализовать несколько интерфейсов).
        
    - Нет общего состояния.
        
- **Абстрактный класс — логичнее, когда:**
    
    - Есть общее состояние (поля) и базовая реализация.
        
    - Нужно защитить от несовместимых реализаций (даёшь скелет).
        
    - Внутри есть защищённые утилиты и шаблонные методы.
        

> Пример: `AbstractList` даёт базовую логику списков, а `List` — интерфейс, который описывает контракт.

## Интерфейсы без методов — “маркерные”

- **Суть:** интерфейс не содержит методов; сам факт его реализации что-то означает для системы.
    
- **Примеры:** `Serializable`, `Cloneable`.
    
- **Зачем:** фреймворки/среда через `instanceof` узнают, можно ли применять особое поведение (например, сериализовать).
    

## Перегрузка и переопределение: модификатор доступа

- **Переопределение (override):** в подклассе меняем реализацию метода родителя.
    
    - **Можно** расширять доступ: `protected` → `public`.
        
    - **Нельзя** сужать: `public` → `protected/private` (нарушает контракт).
        
- **Перегрузка (overload):** в одном классе несколько методов с одним именем, но разными параметрами.
    
    - Модификатор доступа может быть любым, не влияет на перегрузку.
        

## Перегрузка и переопределение: возвращаемый тип и параметры

- **Переопределение:**
    
    - **Параметры:** должны совпадать по сигнатуре (имена не важны).
        
    - **Возвращаемый тип:** может быть ковариантным — более специфичным подтипом оригинального (например, `Object` → `String` нельзя, но `Animal` → `Dog` можно).
        
- **Перегрузка:**
    
    - **Параметры:** меняем тип/количество/порядок (компилятор различает по сигнатуре).
        
    - **Возвращаемый тип:** можно менять, но сам по себе он не различает перегрузку — нужен отличающийся список параметров.
        

> Важная ловушка: автобоксинг и varargs могут вызывать неоднозначность перегрузки — знай приоритеты (точное совпадение типов > примитивы > боксинг > varargs).

## 38. Можно ли менять возвращаемый тип метода и тип параметров?

- **Перегрузка**: можно менять параметры (количество, тип). Возвращаемый тип может быть любым.
    
- **Переопределение**: возвращаемый тип можно менять только на совместимый (например, родительский метод возвращает `Animal`, а дочерний — `Dog`). Параметры менять нельзя.
    

## 39. Каким образом передаются переменные в методы?

- В Java всё передаётся **по значению**.
    
- Но если это объект, то передаётся значение **ссылки**. То есть метод получает копию адреса объекта, и может менять сам объект, но не ссылку.
    

## 40. Что такое конструктор по умолчанию?

- Это специальный метод, который создаёт объект.
    
- Если мы не написали свой конструктор, Java автоматически создаёт пустой конструктор без параметров.
    

## 41. Свойства конструктора. Способы его вызова.

- Конструктор:
    
    - имеет то же имя, что и класс,
        
    - не возвращает значение,
        
    - вызывается при создании объекта через `new`.
        
- Пример:
    
    java
    
    ```
    class Car {
        Car() { // конструктор
            System.out.println("Car created!");
        }
    }
    
    Car c = new Car(); // вызов конструктора
    ```
    

## 42. Mutable и Immutable классы.

- **Mutable (изменяемые)** — объект можно менять. Пример: `ArrayList`.
    
- **Immutable (неизменяемые)** — объект нельзя менять после создания. Пример: `String`.
    
- Чтобы создать immutable-класс:
    
    - сделать поля `private final`,
        
    - не давать сеттеров,
        
    - возвращать копии коллекций.
        
- В Java есть специальный тип — **record**, который автоматически создаёт immutable-класс:
    
    java
    
    ```
    record Point(int x, int y) {}
    ```
    

## 43. static — что это?

- `static` означает, что поле или метод принадлежит классу, а не объекту.
    
- Если изменить `static` поле через один объект, оно изменится для всех.
    
- Пример:
    
    java
    
    ```
    class Counter {
        static int count = 0;
    }
    
    Counter c1 = new Counter();
    Counter c2 = new Counter();
    c1.count = 5;
    System.out.println(c2.count); // будет 5
    ```
    

## 44. Может ли статический метод быть перегружен или переопределён?

- **Перегружен** — да, можно создать несколько статических методов с одинаковым именем, но разными параметрами.
    
- **Переопределён** — нет, статические методы принадлежат классу, а не объекту. Их можно **скрыть** (hide), но это не настоящее переопределение.