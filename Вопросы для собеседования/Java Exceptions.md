## Иерархия исключений

- **Корень:** `Throwable` абстрактный класс Суперкласс всего, что можно бросать/ловить. Имеет две основные ветки: `Error` и `Exception`.
    
- **Ветка ошибок:** `Error` **Назначение:** критические ошибки времени исполнения, обычно не обрабатываются приложением. **Примеры:** `OutOfMemoryError`, `StackOverflowError`, `InternalError`. **Особенность:** указывает на проблемы JVM/среды, а не бизнес-логику.
    
- **Ветка исключений:** `Exception` **Назначение:** ситуации, которые приложение может (и должно) обрабатывать. **Подветка** `RuntimeException`**:** unchecked-исключения, ошибки программирования. **Примеры checked:** `IOException`, `SQLException`, `ClassNotFoundException`. **Примеры unchecked:** `NullPointerException`, `IllegalArgumentException`, `IndexOutOfBoundsException`, `ConcurrentModificationException`.
    

## Checked и unchecked исключения

- **Checked (проверяемые):**
    
    - **Требование:** обязательно обработать (`try-catch`) или объявить в сигнатуре метода (`throws`).
        
    - **Смысл:** сигнализируют о ожидаемых внешних сбоях (I/O, БД, сеть).
        
    - **Примеры:** `IOException`, `SQLException`, `ParseException`.
        
- **Unchecked (непроверяемые):**
    
    - **Требование:** объявления не требуют; могут возникать в любом месте.
        
    - **Смысл:** ошибки программирования (валидация, контракт, инварианты).
        
    - **Примеры:** `NullPointerException`, `IllegalStateException`, `ArithmeticException`, `ClassCastException`.
        
- **Ключевые отличия:**
    
    - **Контракт компилятора:** checked — принудительная обработка/объявление; unchecked — нет.
        
    - **Цель:** checked — внешние, ожидаемые проблемы; unchecked — логические дефекты кода.
        
    - **Дизайн:** бросайте unchecked для нарушения предусловий/инвариантов; используйте checked там, где вызывающий реально может восстановиться.
        

## Блок try-catch-finally

- **Назначение:**
    
    - **try:** код, где может возникнуть исключение.
        
    - **catch:** обработка конкретного типа исключения.
        
    - **finally:** гарантированные действия (закрытие ресурсов, восстановление состояния).
        
- **Работа без catch:**
    
    - **Да, возможно.**
        
    - **Варианты:** `try-finally` (без `catch`) или `try-with-resources` без `catch` — ресурсы закроются, исключение «поднимется» дальше.
        
    
    java
    
    ```
    try {
        risky();
    } finally {
        cleanup();
    }
    ```
    
- **Порядок блоков catch:**
    
    - **От более специфичных к более общим.**
        
    - **Правило:** если общий тип (например, `Exception`) стоит раньше конкретного (например, `IOException`), второй `catch` станет недостижимым → ошибка компиляции.
        
    
    java
    
    ```
    try { /* ... */ }
    catch (FileNotFoundException e) { /* конкретный */ }
    catch (IOException e) { /* более общий для I/O */ }
    catch (Exception e) { /* самый общий */ }
    ```
    
- **Multi-catch (с Java 7):**
    
    - **Формат:** `catch (IOException | SQLException e)` — один обработчик для нескольких несмежных типов.
        
    - **Ограничения:** типы не должны иметь отношение «родитель–потомок»; переменная `e` — effectively final (нельзя присвоить новое значение).
        
- **Поведение finally:**
    
    - **Гарантии:** выполняется при нормальном завершении, `return` и при исключениях.
        
    - **Исключения:** может не выполниться при `System.exit`, `Runtime.halt`, аварийном завершении JVM, убийстве процесса, критических ошибках в JVM.
        
    - **Предупреждение:** если `finally` бросает исключение, оно может «перекрыть» исходное; учитывайте подавленные исключения.
        

## Try-with-resources

- **Назначение:** автоматическое закрытие ресурсов, реализующих `AutoCloseable` или `Closeable`.
    
    - **Форма:** ресурсы объявляются в круглых скобках; закрываются автоматически в конце блока.
        
    
    java
    
    ```
    try (BufferedReader br = Files.newBufferedReader(path);
         BufferedWriter bw = Files.newBufferedWriter(out)) {
        bw.write(br.readLine());
    } // bw.close() и br.close() вызовутся автоматически
    ```
    
- **Порядок закрытия:**
    
    - **Обратный порядку объявления.** Если объявлены A, затем B — сначала закрывается B, потом A.
        
- **Исключения при закрытии:**
    
    - **Подавленные исключения:** если в try произошло исключение X, а при закрытии возникло Y, то Y добавляется как suppressed к X.
        
    - **Доступ:** `X.getSuppressed()` вернёт массив подавленных исключений.
        
    
    java
    
    ```
    try (MyRes r = new MyRes()) {
        r.use();
    } catch (Exception e) {
        for (Throwable t : e.getSuppressed()) {
            log(t);
        }
    }
    ```
    
- **Ресурсы вне скобок (Java 9+):**
    
    - Можно передать уже созданные и «final/эффективно final» ресурсы:
        
    
    java
    
    ```
    BufferedReader br = Files.newBufferedReader(path);
    try (br) {
        // ...
    }
    ```
    
- **Лучшие практики:**
    
    - **Используйте всегда для I/O, JDBC, потоков, каналов,** `ZipInputStream`**,** `HttpClient`**-ресурсов.**
        
    - **Не смешивайте ручное закрытие и try-with-resources.**
        
    - **Логируйте suppressed, если важно видеть полную картину ошибок.**
        

## Короткие примеры

- **Multi-catch:**
    
    java
    
    ```
    try {
        readFromNetwork();
        readFromDisk();
    } catch (IOException | SocketException e) {
        // SocketException наследует IOException → так нельзя (пример ограничения)
    }
    ```
    
- **Правильный multi-catch:**
    
    java
    
    ```
    try {
        callDb();
        parseJson();
    } catch (SQLException | JsonProcessingException e) {
        handle(e);
    }
    ```
    
- **Try-finally без catch:**
    
    java
    
    ```
    try {
        process();
    } finally {
        closeQuietly();
    }
    ```
## 61. Что такое `Error`

- `Error` — подкласс `Throwable`, наряду с `Exception`.
    
- Используется JVM для сигнализации о **критических ошибках**, которые обычно невозможно обработать на уровне приложения.
    
- Примеры: `OutOfMemoryError`, `StackOverflowError`, `VirtualMachineError`.
    

**Перехват** `Error`**:**

- Обычно **не имеет смысла**, так как это ошибки среды выполнения, а не бизнес-логики.
    
- Исключение: иногда можно перехватить для логирования или graceful shutdown (например, чтобы записать в лог, что случился `OutOfMemoryError`).
    
- Но восстанавливаться после `Error` почти всегда невозможно.
    

## 62. Отличие `OutOfMemoryError` от `StackOverflowError`

- `OutOfMemoryError`
    
    - Возникает, когда JVM не может выделить память в heap.
        
    - Причины: утечки памяти, слишком большие объекты, бесконечные коллекции.
        
    - Избежать:
        
        - Профилировать память (`VisualVM`, `YourKit`).
            
        - Использовать слабые ссылки (`WeakReference`).
            
        - Следить за утечками (закрывать ресурсы, чистить коллекции).
            
        - Настроить `-Xmx` (максимальный размер heap).
            
- `StackOverflowError`
    
    - Возникает при переполнении стека вызовов (обычно бесконечная рекурсия).
        
    - Причины: рекурсивные вызовы без базового условия.
        
    - Избежать:
        
        - Переписать рекурсию в итерацию.
            
        - Проверять условия выхода.
            
        - Настроить размер стека (`-Xss`).
            

## 63. Оператор `throw`

- Используется для **явного выброса исключения**.
    
- Синтаксис:
    
    java
    
    ```
    throw new Exception("message");
    ```
    
- Свойства:
    
    - Бросает **один объект**, который должен быть наследником `Throwable`.
        
    - После `throw` выполнение метода прекращается.
        
    - Если это checked-исключение, метод должен объявить `throws`.
        
    - Отличие от `throws`:
        
        - `throw` — выбросить конкретный объект.
            
        - `throws` — объявить, что метод может выбросить исключение.
            

## 64. Задача с try-catch-finally

Код:

java

```
try {
    a = 5;
    throw new Exception("1");
} catch (Exception e) {
    a = 10;
    throw new Exception("2");
} finally {
    a = 15;
    throw new Exception("3");
}
```

### Пошаговое выполнение:

1. В `try`:
    
    - `a = 5`.
        
    - Бросается `Exception("1")`.
        
2. Переход в `catch`:
    
    - `a = 10`.
        
    - Бросается новое `Exception("2")`.
        
3. Выполняется `finally`:
    
    - `a = 15`.
        
    - Бросается новое `Exception("3")`.
        

### Итог:

- Исключение из `finally` **перекрывает** все предыдущие (`"1"` и `"2"`).
    
- В итоге будет выброшено `Exception("3")`.
    
- Значение переменной `a` = **15**.